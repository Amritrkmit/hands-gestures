<!DOCTYPE html>

<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Hand‑Tracked 3D Particle Universe</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <style>
    body { margin: 0; overflow: hidden; background: #000; }

    #info {
      position: fixed;
      bottom: 12px;
      left: 12px;
      color: #fff;
      font-family: system-ui, sans-serif;
      font-size: 14px;
      background: rgba(0,0,0,0.55);
      padding: 8px 12px;
      border-radius: 8px;
      z-index: 10;
    }

    #cameraPopup {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.85);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }

    .popup-content {
      background: #111;
      color: #fff;
      padding: 28px 32px;
      border-radius: 14px;
      max-width: 400px;
      text-align: center;
      font-family: system-ui, sans-serif;
    }

    .popup-content button {
      margin-top: 18px;
      padding: 10px 22px;
      font-size: 14px;
      border-radius: 8px;
      border: none;
      cursor: pointer;
      background: #00e5ff;
      color: #000;
      font-weight: 600;
    }
  </style>

</head>
<body>

<div id="info">Waiting for camera permission…</div>

<div id="cameraPopup">
  <div class="popup-content">
    <h3>Camera Access Required</h3>
    <p>This experience uses your camera for real‑time hand gesture interaction.</p>
    <button id="enableCamera">Enable Camera</button>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.min.js"></script>

<script>
/* ===================== THREE ===================== */
const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x000000, 30, 120);

const camera = new THREE.PerspectiveCamera(65, innerWidth / innerHeight, 0.1, 300);
camera.position.z = 55;

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

/* ===================== PARTICLES ===================== */
const COUNT = 12000;
const geometry = new THREE.BufferGeometry();
const positions = new Float32Array(COUNT * 3);
const colors = new Float32Array(COUNT * 3);

geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

const material = new THREE.PointsMaterial({ size: 0.25, vertexColors: true, transparent: true, opacity: 0.9 });
const particles = new THREE.Points(geometry, material);
scene.add(particles);

/* ===================== SHAPES (20+) ===================== */
const shapes = {
  sphere: () => new THREE.Vector3().randomDirection().multiplyScalar(Math.random()*10).toArray(),
  cube: () => [(Math.random()-.5)*15,(Math.random()-.5)*15,(Math.random()-.5)*15],
  ring: () => {const a=Math.random()*Math.PI*2;return[Math.cos(a)*10,Math.sin(a)*10,0];},
  spiral: () => {const t=Math.random()*20;return[Math.cos(t)*t/3,Math.sin(t)*t/3,(Math.random()-.5)*5];},
  heart: () => {const t=Math.random()*Math.PI*2;const r=2-2*Math.sin(t);return[r*Math.cos(t),r*Math.sin(t),(Math.random()-.5)*2];},
  flower: () => {const t=Math.random()*Math.PI*2;const r=6*Math.sin(5*t);return[Math.cos(t)*r,Math.sin(t)*r,(Math.random()-.5)*2];},
  saturn: () => {const a=Math.random()*Math.PI*2;return[Math.cos(a)*9,(Math.random()-.5),Math.sin(a)*9];},
  fireworks: () => new THREE.Vector3().randomDirection().multiplyScalar(Math.random()*14).toArray(),
  wave: () => {const x=(Math.random()-.5)*20;return[x,Math.sin(x)*5,(Math.random()-.5)*4];},
  dna: () => {const t=Math.random()*20;return[Math.cos(t)*4,t-10,Math.sin(t)*4];},
  cone: () => {const r=Math.random()*8;const a=Math.random()*Math.PI*2;return[Math.cos(a)*r,Math.random()*10,Math.sin(a)*r];},
  galaxy: () => {const t=Math.random()*50;return[Math.cos(t)*t/5,(Math.random()-.5)*5,Math.sin(t)*t/5];},
  torus: () => {const a=Math.random()*Math.PI*2;const b=Math.random()*Math.PI*2;return[(10+3*Math.cos(b))*Math.cos(a),(10+3*Math.cos(b))*Math.sin(a),3*Math.sin(b)];},
  pyramid: () => [(Math.random()-.5)*10,Math.random()*10,(Math.random()-.5)*10],
  cross: () => Math.random()>0.5?[Math.random()*10-5,0,0]:[0,Math.random()*10-5,0],
  helix: () => {const t=Math.random()*20;return[Math.cos(t)*5,t-10,Math.sin(t)*5];},
  plane: () => [(Math.random()-.5)*20,(Math.random()-.5)*20,0],
  burst: () => new THREE.Vector3().randomDirection().multiplyScalar(Math.random()*20).toArray(),
  star: () => {const a=Math.random()*Math.PI*2;const r=Math.random()>0.5?8:4;return[Math.cos(a)*r,Math.sin(a)*r,0];},
  infinity: () => {const t=Math.random()*Math.PI*2;return[Math.sin(t)*8,Math.sin(t)*Math.cos(t)*8,0];}
};

const shapeKeys = Object.keys(shapes);
let shapeIndex = 0;
let expansion = 1;
let hue = 0;

function buildShape() {
  for (let i=0;i<COUNT;i++){
    const p = shapes[shapeKeys[shapeIndex]]();
    positions[i*3]=p[0]*expansion;
    positions[i*3+1]=p[1]*expansion;
    positions[i*3+2]=p[2]*expansion;
    const c = new THREE.Color(`hsl(${hue},100%,60%)`);
    colors[i*3]=c.r;colors[i*3+1]=c.g;colors[i*3+2]=c.b;
  }
  geometry.attributes.position.needsUpdate=true;
  geometry.attributes.color.needsUpdate=true;
}

buildShape();

/* ===================== MEDIAPIPE ===================== */
const video=document.createElement('video');video.style.display='none';document.body.appendChild(video);
const hands=new Hands({locateFile:f=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
hands.setOptions({maxNumHands:1,modelComplexity:1,minDetectionConfidence:.7,minTrackingConfidence:.7});

let lastSwitch=0;
hands.onResults(res=>{
  if(!res.multiHandLandmarks||!res.multiHandLandmarks.length) return;
  const lm=res.multiHandLandmarks[0]; if(lm.length<9) return;
  const d=Math.hypot(lm[4].x-lm[8].x,lm[4].y-lm[8].y);
  expansion=THREE.MathUtils.lerp(expansion,d*35,.25);
  hue=(hue+1)%360;
  if(d<.05 && performance.now()-lastSwitch>600){shapeIndex=(shapeIndex+1)%shapeKeys.length;lastSwitch=performance.now();}
  document.getElementById('info').innerText=`Shape: ${shapeKeys[shapeIndex]} | Pinch: ${d.toFixed(3)}`;
  buildShape();
});

const cam=new Camera(video,{onFrame:async()=>await hands.send({image:video}),width:640,height:480});

/* ===================== POPUP ===================== */
document.getElementById('enableCamera').onclick=async()=>{
  try{await navigator.mediaDevices.getUserMedia({video:true});cam.start();document.getElementById('cameraPopup').style.display='none';}
  catch{document.getElementById('info').innerText='Camera permission denied';}
};

/* ===================== LOOP ===================== */
function animate(){requestAnimationFrame(animate);particles.rotation.y+=.002;particles.rotation.x+=.001;renderer.render(scene,camera);}animate();
window.onresize=()=>{camera.aspect=innerWidth/innerHeight;camera.updateProjectionMatrix();renderer.setSize(innerWidth,innerHeight)};
</script>

</body>
</html>
